
[HTTP] : 이동 문자 전송 규약

[WS] : WebSocket
	- 정의 : WS 프로토콜을 기반으로 클라이언트와 서버(톰캣) 사이에 지속적인 양방향 연결(통신)
	- 특징
		- WS(상태유지)		: 지속적인 양방향 연결, 상태를 유지, 저장 O
			- 클라이언트가 서버에게 연결을 신청
			- 연결된 상태를 유지하고 지속적인 양방향 통신 요청이 가능한 구조
			- 사용처 : 실시간 양방향통신(채팅/알림), 보안
		- HTTP(무상태)	: 무상태, 저장 X
			- 클라이언트가 요청(request)하고 서버가 응답(response)하는 통신구조
			- HTTP는 요청이 있어야만 응답이 존재한다.
			- 사용처 : HTML(웹페이지)통신, REST(자료)통신
	- 소켓
		- 통신의 종착점(End Point = 통신을 주고 받을때 도착 지점)
		- 클라이언트 소켓이 서버 소켓으로부터 최초 연결을 요청
		
	- 구조
		- 클라이언트 소켓 <----> 서버 소켓
			1. 클라이언트 소켓이 서버 소켓에게 연결(접속)을 요청
			2. 서버 소켓이 클라이언트 소켓의 요청을 등록(바인딩)
			==============================================================
			3. 서버 소켓에 등록된 클라이언트 소켓이 서버 소켓에게 메시지 전송 (클라이언트 --> 서버)
			4. 서버 소켓이 클라이언트 소켓으로부터 메시지를 받아 로직(서비스)를 처리
			==============================================================
			3. 서버 소켓이 등록된(상태유지) 클라이언트 소켓에게 메시지 전송 (서버 --> 클라이언트) 
			4. 클라이언트 소켓이 서버 소켓으로부터 메시지를 받아 로직(서비스)를 처리
			
	- 라이브러리
		- JS 웹소켓 라이브러리(내장)(클라이언트)
			- WebSocket클래스
				- 속성 : 각 속성을 제공받고 각 속성에 어떠한 이벤트(함수)을 실행할지 개발자가 구현
					- .onmessage	: 웹소켓이 메세지를 받을때 (자동) 실행되는 속성
						- .onmessage = (event) { 메세지를 받았을때의 로직 구현 }
					- .onopen		: 웹소켓이 서버소켓과 연결/접속에 성공했을때 (자동) 실행되는 속성
						- .onopen = (event) { 서버소켓과 연결이 성공했을때 로직 구현 }
					- .onclose		: 웹소켓이 서버소켓과 연결/접속을 닫았을때 (자동)실행되는 속성
						- .onclose = (event) { 서버소켓과 연결을 닫았을때 로직 구현 }
					- .onerror		: 웹소켓이 서버소켓과 연결/접속에 오류가 발생했을때 (자동) 실행되는 속성
						- .onerror = (event) { 서버소켓과 연결에 오류가 발생했을때 로직 구현 }
						
				- 메소드
					- .send()	: 연결된 서버소켓에게 메세지를 보낼때 사용되는 함수, 텍스트(문자)타입만 가능, 객체 = JSON타입으로 변환이 필요
					
		- Servlet 웹소켓 라이브러리(내장)(서버)
			- 메소드
				- @OnOpen
				  public void onOpen(Session session) {
				  	클라이언트소켓이 접속했을때의 로직 구현
				  }
				  
				- @OnMessage
				  public void onMessage(Session session, String message) {
				  	클라이언트소켓이 보낸 메세지를 받았을때의 로직 구현
				  }
				  
				- @OnClose
				  public void onClose(Session session) {
				  	클라이언트소켓과 연결이 닫혔을때의 로직 구현
				  }
				  
				- @OnError
				  public void onError(Session session) {
				  	클라이언트소켓과 에러가 발생했을때의 로직 구현
				  }
				  
	- 서버소켓은 1개, 클라이언트소켓(유저)은 여러개 존재한다.
		- 서버소켓은 클라이언트소켓들을 저장하고 관리해야한다.
		- 서버소켓은 클라이언트들의 접속상태를 알고 있어야한다. (DB에 저장)
		- 예시
			유저1(강호동)
			유저2(신동엽)
			- 강호동과 신동엽이 메세지를 주고 받는것이 아니다.
			- 강호동이 카카오서버에 메세지를 보내고 카카오서버가 같은방에 있는 신동엽과 강호동에게 메세지를 전달한다.
				  
[동기식 통신 VS 비동기식 통신]
	- 생활속 예시
		- 신동엽이 커피, 빵, 스무드 주문(요청)하고 진동벨(3번)을 받는다.
		- 강호동이 커피를 주문(요청)하고 진동벨(4번)을 받는다.
		------> 사장님 마음대로 주문번호 순서대로 음식을 전달(응답)
		------> 효율적으로 먼저 빠르게 만들어진 음식을 전달(응답)
		비동기식은 요청을 보내고 응답이 올때까지 대기 상태를 만들기 않는다.
		동기식은 요청을 보내고 응답이 올때까지 다음 요청을 받지 않고 대기 상태를 만든다.
		
	- 비동기식 통신 사용처 : fetch 함수, socket 함수
	- 비동기식 통신 : 요청(함수 실행) 응답이 올때까지 대기상태가 아닌 다음 JS 코드를 실행한다.
			
			
			
			
			
			