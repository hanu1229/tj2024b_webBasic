[제네릭 타입]
	1. 정의 : 여러 가지 타입에서 동작할 수 있도록 만든 문법
	2. 목적 : 클래스를 만들때 멤버변수의 타입을 정하지 않고 인스턴스를 생성할 때 변수의 타입을 정한다.
			 다양한 타입의 데이터를 처리할 수 있다.
	3. 사용법
		※ < > : 꺽은 괄호를 이용한 표현, 제네릭타입명은 주로 T를 많이 사용
		※ 주로 제네릭타입명은 대문자 1문자로 작성
		- 클래스 정의
			 - class 클래스명<제네릭타입명> { 제네릭타입명 멤버변수명; }
			 - class 클래스명<제네릭타입명A, 제네릭타입명B, ...> {
			 		제네릭타입명A 멤버변수명;
			 		제네릭타입명B 멤버변수명;
			 	}
			
		- 제네릭 타입을 이용한 인스턴스 생성, 뒤에 타입명은 생략이 가능
			- 클래스명<타입명> 인스턴스명 = new 클래스명<타입명>();
			- 클래스명<타입명, 타입명> 인스턴스명 = new 클래스명<타입명, 타입명>();
			
	4. 사용처 : 컬렉션 프레임워크, ArrayList<>
	5. 특징
		- 변수의 유연성
		- 코드의 중복 제거
		- 잘못된 타입 방지
		
[컬렉션 프레임워크]
	- 컬렉션(수집) 프레임(미리 만들어진 틀) 워크(일) : 일을 할때 수집에 관련해서 미리 만들어진 틀(라이브러리)을 제공
	1. 정의 : 자료들을 수집/저장하는 방법을 미리 만들어 둔 인터페이스/클래스/메소드들의 집합소
	2. 목적 : 복잡한 자료구조를 제공받아 편리한 데이터 관리를 할 수 있다.
		※ 자료구조 : 컴퓨터가 데이터를 저장하는 효율적인 방법들
			예시) 큐/스택/해시/트리 등등
			
	3. 컬렉션 인터페이스 종류
		[1] List 인터페이스
			- 구현객체 : 저장된 순서(인덱스)를 이용한 데이터관리와 데이터의 중복을 허용한다.
				- ArrayList 클래스
				- Vector 클래스 : 멀티스레드에서 주로 사용한다. *동기화된 메소드를 제공한다*
				- LinkedList 클래스 : 중간 삽입/삭제는 ArrayList보다 좋은 성능을 가진다.
			- 메소드
				- .add(자료) : 리스트 내 지정한 자료를 마지막 요소에 추가
				- .add(인덱스, 자료) : 리스트 내 지정한 인덱스에 지정한 자료의 요소 추가
				- .set(인덱스, 자료) : 리스트 내 지정한 인덱스에 지정한 자료의 요소 수정
				- .get(인덱스) : 리스트 내 지정한 인덱스의 요소 값을 반환
				- .size() : 리스트 내 요소 전체 개수를 반환
				- .contains(자료) : 리스트 내 저장한 자료의 존재 여부를 반환(true/false)
				- .indexOf(자료) : 리스트 내 지정한 자료의 인덱스 번호를 반환 없으면 -1을 반환
				- .remove(인덱스 또는 자료) : 리스트 내 지정한 인덱스 또는 자료의 요소를 삭제
				- .clear() : 리스트내 모든 요소를 삭제
				- .isEmpty() : 리스트 내 요소가 비어있으면 true 아니면 false
				- .forEach(()->{}) : 리스트 내 요소들을 순회
 		[2] Set 인터페이스
 			※ Iterator 타입, Iterator는 반복자라는 뜻을 가지고 있다.
 				- .hasNext() : 다음 요소가 존재하면 true 없으면 false
 				- .next() : 다음 요소 값을 반환
 			※ Set은 인덱스가 없으므로 인덱스로 조회할 수 없다.
			- 구현객체 : 저장된 순서가 없고 메모리의 주소값으로 데이터를 관리해서 중복을 허용하지 않는다.
				- HashSet 클래스 : 저장 순서가 없고 중복을 허용하지 않는다
				- TreeSet 클래스 : 저장 순서가 없고 중복을 허용하지 않고 자동으로 오름차순 정렬을 해준다.
					- .descendingSet() : 내림차순으로 정렬
			- 메소드
				- .add(자료) : set 내 지정한 자료를 추가
				- .size() : set 내 전체 요소 개수를 반환
				- .remove(자료) : set 내 지정한 자료가 존재하면 삭제
				- .contains(자료) : set 내 지정한 자료가 존재하는지 여부를 반환
				- .iterator() : set 내 반복자 인터페이스를 반환하는 함수
				- forEach(()->{}) : Iterator 기반으로 만들었기 때문에 사용 가능
			
		[3] Map 인터페이스
			- 구현객체 : 저장된 순서 없이 key와 value로 entry(엔트리/한쌍)를 저장하는 구조
						key는 중복 불가능 value는 중복 가능
				- HashMap 클래스
				- HashTable 클래스
				- HashTree 클래스
				
			- 메소드
				- .put("key", value) : map 내 key와 value를 한쌍으로 저장
				- .get("key") : map 내 지정한 key의 value값을 반환
				- .size() : map 내 전체 entry의 개수를 반환
				- .remove("key") : map 내 지정한 key의 엔트리값 삭제
				- .containsKey("key") : map 내 지정한 key의 존재여부를 반환
				- .containsValue(value) : map 내 지정한 value의 존재여부를 반환
				- .entry() : map 내 모든 entry를 반환하는 함수
				- .keySet() : map 내 모든 key를 반환하는 함수
				- .values() : map 내 모든 value를 반환하는 함수
		
※ 인터페이스 : 무엇을 사용할지 정의해 두는 것(추상메소드 : 메소드를 선언만 하고 구현하지 않는 메소드)
※ 구현(객)체 : 인터페이스를 구현한 객체(클래스가 인터페이스를 implement해서 추상메소드를 오버라이딩한 객체)